<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TypeScript</title>
      <link href="/2022/04/05/typescript/"/>
      <url>/2022/04/05/typescript/</url>
      
        <content type="html"><![CDATA[<blockquote><p>正在持续更新</p></blockquote><h1 id="TypeScript学习"><a href="#TypeScript学习" class="headerlink" title="TypeScript学习"></a>TypeScript学习</h1><h2 id="TypeScript环境配置"><a href="#TypeScript环境配置" class="headerlink" title="TypeScript环境配置"></a>TypeScript环境配置</h2><ul><li>电脑全局安装：<code>npm install -g typescript</code><ul><li>检查是否安装和安装的版本 <code>tsc -v</code></li></ul></li><li>也需要安装Node.js </li></ul><h2 id="TypeScript运行"><a href="#TypeScript运行" class="headerlink" title="TypeScript运行"></a>TypeScript运行</h2><ul><li>新建一个main.ts文件，输入:<ul><li><img src="https://choichoi-1310042158.cos.ap-singapore.myqcloud.com/20220405163617.png"></li></ul></li><li>在terminal中将.ts文件编译成.js文件<ul><li><code>tsc main.ts </code></li></ul></li><li>然后运行<ul><li><code>node main.js</code> </li></ul></li><li>就可以在teminal中看到”hello world”了<ul><li>为什么.js文件没有编译就能运行？</li><li>因为NodeJS原生支持TypeScript。<ul><li>可以直接用<code>node main.ts</code>运行.ts文件</li></ul></li></ul></li></ul><h2 id="TypeScript工作流"><a href="#TypeScript工作流" class="headerlink" title="TypeScript工作流"></a>TypeScript工作流</h2><ul><li>写好ts代码以后，要用ts的编译器把.ts文件编译为.js文件，然后又浏览器调用并且执行.js文件。</li><li>ts的编译器就叫做TSC。</li><li>为什么需要TSC编译？<ul><li>因为大部分主流浏览器还不支持TypeScript.</li></ul></li></ul><h2 id="TypeScript-demo项目依赖"><a href="#TypeScript-demo项目依赖" class="headerlink" title="TypeScript demo项目依赖"></a>TypeScript demo项目依赖</h2><ol><li><code>npm init</code></li><li><code>npm i --save-dev lite-server</code></li></ol><ul><li>lite-server是用来开发的轻量级服务器。</li><li>package.json中的”devDependencies”和”dependencies”区别<ul><li>devDependencies是参与项目开发，项目开发完成上线并不需要打包部署到服务器中。</li><li>dependencies下所有的依赖都会被打包放到服务器上。</li><li>区分的好处：有效降低网站大小，缩短用户打 开网站的时间。</li></ul></li></ul><ol start="3"><li>添加”start”: “lite-server”到package.json中的script下。<ol><li>可以自动部署在localhost:3000。</li></ol></li></ol><h2 id="TypeScript-基础"><a href="#TypeScript-基础" class="headerlink" title="TypeScript 基础"></a>TypeScript 基础</h2><h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><ul><li>通常用let。<ul><li>使用var的坏处：<ul><li>只有全局作用域和函数作用域，没有块级作用域。而且可以多次声明相同的变量。</li></ul></li><li>let就是用来解决var所带来的的问题。<pre class="line-numbers language-none"><code class="language-none">function doSomething(){  for (var i=0; i&lt; 5; i++){    console.log(i);  }// 跳出for循环之后，i还是存在。i=5。// 使用let可以解决这个问题，会立马报错。  console.log("finally i = ", i);}doSomething()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h3 id="TypeScript的基本类型"><a href="#TypeScript的基本类型" class="headerlink" title="TypeScript的基本类型"></a>TypeScript的基本类型</h3><ul><li><p>常见的：boolean, string, number, array, null, undefined, object.</p></li><li><p>不常见的：tuple, enum, void, never, any.</p></li><li><p>常见高级类型：</p><ul><li>Union 联合类型</li><li>Nullable 可空类型</li><li>Literal 预定义类型</li></ul></li></ul><h4 id="number-string-boolean"><a href="#number-string-boolean" class="headerlink" title="number, string, boolean"></a>number, string, boolean</h4><h5 id="number"><a href="#number" class="headerlink" title="number"></a>number</h5><ul><li>既能表示整数，也能表示浮点数或者正负数。</li></ul><h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><ul><li>“hello”, ‘hello’, `hello`</li><li>反引号：``，可以创建一个字符串模板。</li></ul><h5 id="noolean-布尔类型"><a href="#noolean-布尔类型" class="headerlink" title="noolean 布尔类型"></a>noolean 布尔类型</h5><ul><li>真、假</li><li>处理逻辑判断</li></ul><h5 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h5>  <pre class="line-numbers language-none"><code class="language-none">&lt;!-- 限定传进来的数据类型为number --&gt;function add(n1: number, n2: number) {  return n1 + n2;}console.log(add(number1, number2));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>  <pre class="line-numbers language-none"><code class="language-none">&lt;!-- 类型限制可以自动映射 --&gt;let isTrue = true;isTrue = "true"; //会报错&lt;!-- 或者手动限制类型 --&gt;let isTrue: boolean = true;isTrue = "true"; //会报错let str: string = "";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="array、tuple"><a href="#array、tuple" class="headerlink" title="array、tuple"></a>array、tuple</h4><h5 id="array-数组类型"><a href="#array-数组类型" class="headerlink" title="array 数组类型"></a>array 数组类型</h5><ul><li>[]</li><li>可以存放任意类型的数据。<pre class="line-numbers language-none"><code class="language-none">// 标准写法let list1: number[] = [1,2,3,4];// 泛型let list2: Array&lt;number&gt; = [1,2,3,4];// 不写类型的偷懒写法let list3 = [1,2,3,4];// 显示类型：let list4: (string | number)[]let list4 = [1, "ddd"];// 显示类型: let list5: anylet list5: any[] = [1, "ddd", true];// 不同：list4只能存放string和number， list5存放任何类型的数据。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="tuple-元祖类型"><a href="#tuple-元祖类型" class="headerlink" title="tuple 元祖类型"></a>tuple 元祖类型</h5><ul><li>特殊的数组。是<strong>固定长度，固定类型的数组</strong>。</li><li>只有<strong>声明时同时指定了变量类型</strong>才是tuple元祖。<ul><li>没有指定类型就是普通的array。<pre class="line-numbers language-none"><code class="language-none">let person1: [number, string] = [1, "ddd"]///下面都会报错person1[0] = "ddd"person1[1] = 1person1[2] = 111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li>需要注意：元祖现在还有bug。<ul><li>push()可以无限拓宽元祖的长度。<pre class="line-numbers language-none"><code class="language-none">person1[2] = 3 //会报错，但如果利用push()则不会报错，还能通过编译。person1.push(3) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li></ul><h4 id="Union联合类型与Literal字面量类型"><a href="#Union联合类型与Literal字面量类型" class="headerlink" title="Union联合类型与Literal字面量类型"></a>Union联合类型与Literal字面量类型</h4><h5 id="Union联合类型"><a href="#Union联合类型" class="headerlink" title="Union联合类型"></a>Union联合类型</h5><ul><li>可以同时支持两个或者几个不同的类型。类型之间用 | 进行分隔，<pre class="line-numbers language-none"><code class="language-none">let union : string | number union = 2;union = "dddd";let union2 : number | string | boolean | string[]function merge(n1: number | string, n2: number | string){  if(typeof n1 === "string" || typeof n2 === "string“)    return n1.toString() + n2.toString()  else    return n1 + n2}let mergeNumber = merge(2,5); //7let mergeString = merge("hello", "world");//hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="Literal字面量类型"><a href="#Literal字面量类型" class="headerlink" title="Literal字面量类型"></a>Literal字面量类型</h5><ul><li>字面量是 JavaScript 本身提供的一个准确变量。</li><li>在声明类型的同时声明值，明确的取值数字的类型。<pre class="line-numbers language-none"><code class="language-none">  //如使用字符串字面量作为一个类型。  let foo: 'Hello';  foo = 'Bar'; //会报错    //确定了值只能为数字0,1,2的union。  let union3: 0 | 1 | 2  union3 = 1  //union3 = 4 //会报错  //改写上面的union2  let union2 : number | string | boolean | string[]  function merge(n1: number | string, n2: number | string, resultType: "as-number" | "as-string"){  //如果resultType是等于"as-string",不管n1和n2是什么类型，让结果输出为string。  if(resultType === "as-string"){    return n1.toString() + n2.toString()  }  if(typeof n1 === "string" || typeof n2 === "string“)    return n1.toString() + n2.toString()  else    return n1 + n2}  let mergeNumber = merge(2,5, "as-number"); //7  let mergeNumber = merge(2,5, "as-string"); //25  let mergeString = merge("hello", "world","as-string");//hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="枚举类型-Enum"><a href="#枚举类型-Enum" class="headerlink" title="枚举类型 Enum"></a>枚举类型 Enum</h4>  <pre class="line-numbers language-none"><code class="language-none">enum Color{  red,  green,  blue} let color = Color.blueconsole.log(color); // 2//同理，Color.red = 0, Color.green = 1//也可以自己定义值enum Color2{  red = 5,  green = 10,  blue = 1}//也可以不是数字，混合string和数字进行处理enum Color3{  red = "red",  green = "green",  blue = 1}let color3 = Color3.greenconsole.log(color3) //输出"green"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="any-和unknown"><a href="#any-和unknown" class="headerlink" title="any 和unknown"></a>any 和unknown</h4><ul><li><p>any是一个动态类型，支持和兼容所有类型</p></li><li><p>在不知道用什么类型的时候可以用any。</p></li><li><p>在日常使用js的时候就是个any类型。 </p></li><li><p>js的灵活性带来的快速开发效率也给代码带来了不可阅读性，不可维护性，不可拓展性等一系列的问题。</p></li><li><p>any类型保留了高灵活性同时带来了强类型语言才有的高可维护性。</p><pre class="line-numbers language-none"><code class="language-none">let randonValue: any = 666;randomValue = true;randomValue = "dddd";randomValue = {};randomValue(); //编译执行到这里的时候会报错。randomValue.toUpperCase()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>unknown和any差不多，但是可以保证类型的安全。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode+腾讯云+PicGo图床</title>
      <link href="/2022/04/05/teng-xun-yun-typora-pei-zhi/"/>
      <url>/2022/04/05/teng-xun-yun-typora-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="vscode-腾讯云-PicGo图床"><a href="#vscode-腾讯云-PicGo图床" class="headerlink" title="vscode+腾讯云+PicGo图床"></a>vscode+腾讯云+PicGo图床</h1><p><strong>1. 配置腾讯云COS存储桶</strong></p><ul><li>做图床的话，访问权限要选”公有读私有写“。<br><img src="https://choichoi-1310042158.cos.ap-singapore.myqcloud.com/20220405011149.png"></li></ul><p><strong>2. 配置密钥</strong></p><ul><li>使用PicGo做插件的话要配置一个密钥让插件使用。</li><li>密钥配置网址：<a href="https://console.cloud.tencent.com/cam/capi">https://console.cloud.tencent.com/cam/capi</a>  </li><li>配置好的密钥：<br><img src="https://choichoi-1310042158.cos.ap-singapore.myqcloud.com/20220405013142.png"></li></ul><p><strong>3. PicGo插件</strong></p><ul><li>在vscode安装PicGo插件。<br><img src="https://choichoi-1310042158.cos.ap-singapore.myqcloud.com/20220405011640.png"></li></ul><p><strong>4. 配置PicGo</strong></p><ul><li>找到PicGo的设置， 主要配置如下：</li><li>Picgo › Pic Bed: Current，选择”tcyun”，即腾讯云。<br><img src="https://choichoi-1310042158.cos.ap-singapore.myqcloud.com/20220405012031.png"></li><li>Picgo › Pic Bed › Tcyun: App ID，设置为腾讯云的APPID，是第二步的一串数字。</li><li>Picgo › Pic Bed › Tcyun: Area，腾讯云的存储桶所在区域，在创建存储桶时提供，如“ap-singapore”。</li><li>Picgo › Pic Bed › Tcyun: Bucket，存储桶的名称，一般是桶名 + “-” + 一串数字，如“test-1310232109“。</li><li>Picgo › Pic Bed › Tcyun: Custom Url，访问域名，直接填请求域名，如”<a href="https://test-1310232109.cos.ap-singapore.myqcloud.com&quot;/">https://test-1310232109.cos.ap-singapore.myqcloud.com"</a></li><li>Picgo › Pic Bed › Tcyun: Secret ID，在上面第二步生成。</li><li>Picgo › Pic Bed › Tcyun: Secret Key，在上面第二步生成。</li><li>Picgo › Pic Bed › Tcyun: Version，使用默认的 v5 就可以。  </li></ul><p><strong>5. 上传方法</strong></p><ul><li>Mac可以把要上传的图片先复制在剪贴板，然后在要插入的地方使用快捷键Command + Option + U。</li><li>Windows可以用Ctrl + Alt + U。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于垃圾回收，内存管理，内存泄漏。</title>
      <link href="/2022/04/04/guan-yu-nei-cun-xie-lou/"/>
      <url>/2022/04/04/guan-yu-nei-cun-xie-lou/</url>
      
        <content type="html"><![CDATA[<p>（还没写完，先留着。刚配置完图床。）</p><h1 id="关于垃圾回收、内存管理、内存泄漏。"><a href="#关于垃圾回收、内存管理、内存泄漏。" class="headerlink" title="关于垃圾回收、内存管理、内存泄漏。"></a>关于垃圾回收、内存管理、内存泄漏。</h1><ul><li>这篇文章主要还是因为面试被问到了内存泄漏。在红宝书上看到过但没有仔细研究，导致一问三不知。接下来重温红宝书。</li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h2 id="垃圾回收（GC）"><a href="#垃圾回收（GC）" class="headerlink" title="垃圾回收（GC）"></a>垃圾回收（GC）</h2><ul><li>垃圾回收（GC）即Garbage Collection。</li></ul><h2 id="内存泄漏是什么？"><a href="#内存泄漏是什么？" class="headerlink" title="内存泄漏是什么？"></a>内存泄漏是什么？</h2><ul><li>个人的理解是，电脑分配给浏览器(或者任何runtime)的内存不够用来跑自己写的<del>垃圾</del>代码了。<del>JS运行占的内存满得都溢出来了。</del><ul><li>比如函数被调用很多次，或者写一个千万级别的循环就会导致浏览器非常卡，甚至造成崩溃。</li><li>特别是内存不够多的设备上，内存没办法分配给浏览器很多，这时候也会有内存泄漏的问题。</li></ul></li></ul><h2 id="为什么会导致？"><a href="#为什么会导致？" class="headerlink" title="为什么会导致？"></a>为什么会导致？</h2><h3 id="意外声明全局变量"><a href="#意外声明全局变量" class="headerlink" title="意外声明全局变量"></a>意外声明全局变量</h3><ul><li>是最常见也</li></ul><ul><li> 参考：<a href="https://juejin.cn/post/6981588276356317214">https://juejin.cn/post/6981588276356317214</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/12/06/hello-world/"/>
      <url>/2021/12/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
