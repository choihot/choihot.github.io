<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TypeScript</title>
      <link href="/2022/04/05/typescript/"/>
      <url>/2022/04/05/typescript/</url>
      
        <content type="html"><![CDATA[<blockquote><p>正在持续更新</p></blockquote><h1 id="TypeScript学习"><a href="#TypeScript学习" class="headerlink" title="TypeScript学习"></a>TypeScript学习</h1><h2 id="TypeScript环境配置"><a href="#TypeScript环境配置" class="headerlink" title="TypeScript环境配置"></a>TypeScript环境配置</h2><ul><li>电脑全局安装：<code>npm install -g typescript</code><ul><li>检查是否安装和安装的版本 <code>tsc -v</code></li></ul></li><li>也需要安装Node.js </li></ul><h2 id="TypeScript运行"><a href="#TypeScript运行" class="headerlink" title="TypeScript运行"></a>TypeScript运行</h2><ul><li>新建一个main.ts文件，输入:<ul><li><img src="https://choichoi-1310042158.cos.ap-singapore.myqcloud.com/20220405163617.png"></li></ul></li><li>在terminal中将.ts文件编译成.js文件<ul><li><code>tsc main.ts </code></li></ul></li><li>然后运行<ul><li><code>node main.js</code> </li></ul></li><li>就可以在teminal中看到”hello world”了<ul><li>为什么.js文件没有编译就能运行？</li><li>因为NodeJS原生支持TypeScript。<ul><li>可以直接用<code>node main.ts</code>运行.ts文件</li></ul></li></ul></li></ul><h2 id="TypeScript工作流"><a href="#TypeScript工作流" class="headerlink" title="TypeScript工作流"></a>TypeScript工作流</h2><ul><li>写好ts代码以后，要用ts的编译器把.ts文件编译为.js文件，然后又浏览器调用并且执行.js文件。</li><li>ts的编译器就叫做TSC。</li><li>为什么需要TSC编译？<ul><li>因为大部分主流浏览器还不支持TypeScript.</li></ul></li></ul><h2 id="TypeScript-demo项目依赖"><a href="#TypeScript-demo项目依赖" class="headerlink" title="TypeScript demo项目依赖"></a>TypeScript demo项目依赖</h2><ol><li><code>npm init</code></li><li><code>npm i --save-dev lite-server</code></li></ol><ul><li>lite-server是用来开发的轻量级服务器。</li><li>package.json中的”devDependencies”和”dependencies”区别<ul><li>devDependencies是参与项目开发，项目开发完成上线并不需要打包部署到服务器中。</li><li>dependencies下所有的依赖都会被打包放到服务器上。</li><li>区分的好处：有效降低网站大小，缩短用户打 开网站的时间。</li></ul></li></ul><ol start="3"><li>添加”start”: “lite-server”到package.json中的script下。<ol><li>可以自动部署在localhost:3000。</li></ol></li></ol><h2 id="TypeScript-基础"><a href="#TypeScript-基础" class="headerlink" title="TypeScript 基础"></a>TypeScript 基础</h2><h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><ul><li>通常用let。<ul><li>使用var的坏处：<ul><li>只有全局作用域和函数作用域，没有块级作用域。而且可以多次声明相同的变量。</li></ul></li><li>let就是用来解决var所带来的的问题。<pre class="line-numbers language-none"><code class="language-none">function doSomething(){  for (var i=0; i&lt; 5; i++){    console.log(i);  }// 跳出for循环之后，i还是存在。i=5。// 使用let可以解决这个问题，会立马报错。  console.log("finally i = ", i);}doSomething()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h3 id="TypeScript的基本类型"><a href="#TypeScript的基本类型" class="headerlink" title="TypeScript的基本类型"></a>TypeScript的基本类型</h3><ul><li><p>常见的：boolean, string, number, array, null, undefined, object.</p></li><li><p>不常见的：tuple, enum, void, never, any.</p></li><li><p>常见高级类型：</p><ul><li>Union 联合类型</li><li>Nullable 可空类型</li><li>Literal 预定义类型</li></ul></li></ul><h4 id="number-string-boolean"><a href="#number-string-boolean" class="headerlink" title="number, string, boolean"></a>number, string, boolean</h4><h5 id="number"><a href="#number" class="headerlink" title="number"></a>number</h5><ul><li>既能表示整数，也能表示浮点数或者正负数。</li></ul><h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><ul><li>“hello”, ‘hello’, `hello`</li><li>反引号：``，可以创建一个字符串模板。</li></ul><h5 id="noolean-布尔类型"><a href="#noolean-布尔类型" class="headerlink" title="noolean 布尔类型"></a>noolean 布尔类型</h5><ul><li>真、假</li><li>处理逻辑判断</li></ul><h5 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h5>  <pre class="line-numbers language-none"><code class="language-none">&lt;!-- 限定传进来的数据类型为number --&gt;function add(n1: number, n2: number) {  return n1 + n2;}console.log(add(number1, number2));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>  <pre class="line-numbers language-none"><code class="language-none">&lt;!-- 类型限制可以自动映射 --&gt;let isTrue = true;isTrue = "true"; //会报错&lt;!-- 或者手动限制类型 --&gt;let isTrue: boolean = true;isTrue = "true"; //会报错let str: string = "";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="array-tuple"><a href="#array-tuple" class="headerlink" title="array, tuple"></a>array, tuple</h4><h5 id="array-数组类型"><a href="#array-数组类型" class="headerlink" title="array 数组类型"></a>array 数组类型</h5><ul><li>[]</li><li>可以存放任意类型的数据。<pre class="line-numbers language-none"><code class="language-none">// 标准写法let list1: number[] = [1,2,3,4];// 泛型let list2: Array&lt;number&gt; = [1,2,3,4];// 不写类型的偷懒写法let list3 = [1,2,3,4];// 显示类型：let list4: (string | number)[]let list4 = [1, "ddd"];// 显示类型: let list5: anylet list5: any[] = [1, "ddd", true];// 不同：list4只能存放string和number， list5存放任何类型的数据。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="tuple-元祖类型"><a href="#tuple-元祖类型" class="headerlink" title="tuple 元祖类型"></a>tuple 元祖类型</h5><ul><li>特殊的数组。是<strong>固定长度，固定类型的数组</strong>。</li><li>只有<strong>声明时同时指定了变量类型</strong>才是tuple元祖。<ul><li>没有指定类型就是普通的array。<pre class="line-numbers language-none"><code class="language-none">let person1: [number, string] = [1, "ddd"]///下面都会报错person1[0] = "ddd"person1[1] = 1person1[2] = 111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li>需要注意：元祖现在还有bug。<ul><li>push()可以无限拓宽元祖的长度。<pre class="line-numbers language-none"><code class="language-none">person1[2] = 3 //会报错，但如果利用push()则不会报错，还能通过编译。person1.push(3) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li></ul><h4 id="Union-Literal"><a href="#Union-Literal" class="headerlink" title="Union, Literal"></a>Union, Literal</h4><h5 id="Union联合类型"><a href="#Union联合类型" class="headerlink" title="Union联合类型"></a>Union联合类型</h5><ul><li>可以同时支持两个或者几个不同的类型。类型之间用 | 进行分隔，<pre class="line-numbers language-none"><code class="language-none">let union : string | number union = 2;union = "dddd";let union2 : number | string | boolean | string[]function merge(n1: number | string, n2: number | string){  if(typeof n1 === "string" || typeof n2 === "string“)    return n1.toString() + n2.toString()  else    return n1 + n2}let mergeNumber = merge(2,5); //7let mergeString = merge("hello", "world");//hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="Literal字面量类型"><a href="#Literal字面量类型" class="headerlink" title="Literal字面量类型"></a>Literal字面量类型</h5><ul><li>字面量是 JavaScript 本身提供的一个准确变量。</li><li>在声明类型的同时声明值，明确的取值数字的类型。<pre class="line-numbers language-none"><code class="language-none">  //如使用字符串字面量作为一个类型。  let foo: 'Hello';  foo = 'Bar'; //会报错    //确定了值只能为数字0,1,2的union。  let union3: 0 | 1 | 2  union3 = 1  //union3 = 4 //会报错  //改写上面的union2  let union2 : number | string | boolean | string[]  function merge(n1: number | string, n2: number | string, resultType: "as-number" | "as-string"){  //如果resultType是等于"as-string",不管n1和n2是什么类型，让结果输出为string。  if(resultType === "as-string"){    return n1.toString() + n2.toString()  }  if(typeof n1 === "string" || typeof n2 === "string“)    return n1.toString() + n2.toString()  else    return n1 + n2}  let mergeNumber = merge(2,5, "as-number"); //7  let mergeNumber = merge(2,5, "as-string"); //25  let mergeString = merge("hello", "world","as-string");//hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h4><ul><li>枚举类型 <pre class="line-numbers language-none"><code class="language-none">enum Color{  red,  green,  blue} let color = Color.blueconsole.log(color); // 2//同理，Color.red = 0, Color.green = 1//也可以自己定义值enum Color2{  red = 5,  green = 10,  blue = 1}//也可以不是数字，混合string和数字进行处理enum Color3{  red = "red",  green = "green",  blue = 1}console.log(color3) //输出"green"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="Any-Unknown"><a href="#Any-Unknown" class="headerlink" title="Any, Unknown"></a>Any, Unknown</h4><ul><li><p>any是一个动态类型，支持和兼容所有类型</p></li><li><p>在不知道用什么类型的时候可以用any。</p></li><li><p>在日常使用js的时候就是个any类型。 </p></li><li><p>js的灵活性带来的快速开发效率也给代码带来了不可阅读性，不可维护性，不可拓展性等一系列的问题。</p></li><li><p>any类型保留了高灵活性同时带来了强类型语言才有的高可维护性。</p><pre class="line-numbers language-none"><code class="language-none">let randonValue: any = 666;randomValue = true;randomValue = "dddd";randomValue = {};randomValue(); //编译执行到这里的时候会报错。randomValue.toUpperCase()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>unknown和any差不多，不能确定变量的类型，但是可以保证类型的安全。</p><pre class="line-numbers language-none"><code class="language-none">用法：将上面的代码略作修改if(typeof randomValue === 'function'){  randomValue();}if(typeof randomValue === 'string'){  randomValue.toUpperCase();}  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如何选择？</p><ul><li>any适合代码的快速成型快速上线，但是会遗留下来一些安全隐患。</li><li>unknown就更保险一点。</li></ul></li></ul><h4 id="Void-Undefined-Never"><a href="#Void-Undefined-Never" class="headerlink" title="Void, Undefined, Never"></a>Void, Undefined, Never</h4><ul><li><p>Void:</p><ul><li>Void和Undefined区别就在于在探讨某个变量到底是否存在的哲学问题。</li><li>Undefined指的是变量没有赋值没有初始化。</li><li>Void指的是变量本身就不存在。</li><li>ts中，所有的void输出的都是undefined。<pre class="line-numbers language-none"><code class="language-none">function printResult(): void {  console.log("lalala")}console.log(printResult(()) //输出undefinedfunction printResult(): undefined {  console.log("lalala")  return //一定要加return,否则会报错  }console.log(printResult(()) //输出undefined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>Never</strong></p><ul><li><strong>一个函数永远执行不完，就是Never的本质。</strong></li><li>用法：用来处理异常或者Promise</li><li>下面的函数本质上没有返回值。返回值的类型会显示”void”。</li><li>下面这个函数不仅没有返回值，还会抛出异常。也就是执行到”throw”的时候就会强行让该函数结束了。永远不会执行完成。<pre class="line-numbers language-none"><code class="language-none">function throwError(message: string, errorCode: number): never{  throw{    message,    errorCode  }}throwError("not found", 404)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>除了抛出异常以外，函数无法执行完成的方法：使用while循环。<pre class="line-numbers language-none"><code class="language-none">function whileLoop(): never{  while(true){    console.log("dddd")  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h3 id="TypeScript的面对对象"><a href="#TypeScript的面对对象" class="headerlink" title="TypeScript的面对对象"></a>TypeScript的面对对象</h3><h4 id="Object-对象类型"><a href="#Object-对象类型" class="headerlink" title="Object 对象类型"></a>Object 对象类型</h4><ul><li><p>js中使用花括号并且以键值类形式实现的数据，都属于对象类型。</p></li><li><p>但是ts更明确来说是key to type，键类型对。</p><pre class="line-numbers language-none"><code class="language-none">const person = {  firstName : "choi",  lastName: "hot",  age: 18}console.log(person.nickname)//调用没有定义的内部变量，js不会报错，但是ts会。//如果不怕麻烦可以这样定义：const person = {  firstName : string,  lastName: string,  age: number} = {  firstName : "choi",  lastName: "hot",  age: 18}&lt;!--   笼统定义object类型不会对代码有任何帮助，ts实际上不知道对象内部结构。  指定了object类型相当于指定了一对空的花括号。  const person: object 相当于 const person: {}   ts知道它是一个对象，但是不知道内部情况。  --&gt;const person: object = {  firstName : "choi",  lastName: "hot",  age: 18}console.log(person.firstName)//会报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Interface-Class"><a href="#Interface-Class" class="headerlink" title="Interface, Class"></a>Interface, Class</h4><ul><li><strong>Interface面对对象接口：</strong></li><li>接口就相当于一份说明书，类的实现都要按照这份说明书来。<pre class="line-numbers language-none"><code class="language-none">let drawPoint = (point) =&gt; {  console.log({x: point.x, y:point.y});}//这个时候没有对point进行类型限制，所以可以随便传参，会导致代码和业务逻辑都出错。//后面两行代码并不会报错。drawPoint({x:105,y:24});drawPoint({x:"choi", y:"hot"});drawPoint({weather: "干燥", temperature:"5oC"});//所以要创建interface接口对point进行类型限制。    interface Point{      x: number;      y: number;    }//将最上面的代码改为：let drawPoint = (point：Point) =&gt; {  console.log({x: point.x, y:point.y});}//这时候刚才没报错的两行代码就会报错了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>因为有对象就会引出了“高内聚，低耦合”的问题。上面的代码中的drawPoint和Point这个对象高度相关，应该用面对对象的思维来解决，不然写的代码都是低内聚的。</li><li>把所有相关的属性和方法都打包在一个集合中，就是Class。</li></ul><ul><li><p><strong>Class类</strong></p></li><li><p>对class的理解：</p><ul><li>封装：对具体细节具体过程的隐藏。<br><img src="https://choichoi-1310042158.cos.ap-singapore.myqcloud.com/20220407152610.png" alt="20220407152610"></li></ul></li><li><p>重写上面的drawPoint代码:</p><pre class="line-numbers language-none"><code class="language-none">interface IPoint{  x: number;  y: number;  drawPoint:()=&gt;void; //打印坐标点信息  getDistances: (p:IPoint) =&gt; number; //需要传入对方坐标点信息}//需要实现IPoint中所有的成员变量和成员方法。class Point implements IPoint{  x: number;   y: number;  drawPoint = () =&gt;{    console.log("x: ", this.x, " y: ", this.y);  }  getDistances = (p: IPoint) =&gt;{    return Math.pow(p.x - this.x, 2) + Math.pow(p.y-this.y,2)  }}const point = new Point();&lt;!-- point.x = 2;point.y = 3; --&gt;point.drawPoint()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>类class就是Point，对象就是这个class Point 的实例。也就是说使用new实例化以后就产生了一个对象。对象也被称作实例，instance。</p></li><li><p>运行drawPoint的时候报错，因为x,y没有初始化。可以直接赋值。</p><ul><li>但更好的方法是<strong>使用构造函数 constructor</strong>。</li><li>改写上述代码：<pre class="line-numbers language-none"><code class="language-none">class Point implements IPoint{x: number; y: number;constructor(x: number, y: number){  this.x = x;  this.y = y;}drawPoint = () =&gt;{  console.log("x: ", this.x, " y: ", this.y);}getDistances = (p: IPoint) =&gt;{  return Math.pow(p.x - this.x, 2) + Math.pow(p.y-this.y,2)  }}const point = new Point(2,3); //通过构造函数，在Point对象初始化的时候就可以给x,y赋值了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>那么如果在实例化的时候并不知道具体需要赋值多少，或者不想赋值怎么办？<ul><li><strong>加一个问号 ? ，变成可选参数。</strong></li><li>或者<strong>给参数一个默认值。</strong><pre class="line-numbers language-none"><code class="language-none">          constructor(x?: number, y: number = 2){            this.x = x;            this.y = y;          }        ```           - 注意：JS构造函数不可以重载，一个类有且仅有一个constructor。      - 上面的赋值方法较为繁琐，于是引入了接下来的访问修饰符的概念。#### Access Modifier  - 访问修饰符分为public, private, protected.  - 一般默认的成员变量都是public<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul></li></ul><p>//利用public改写上面的代码:<br>class Point implements IPoint{<br>  //不需要在这里声明x,y的类型。<br>  //不能再使用”?”做可选参数。<br>  constructor(public x: number, public y: number = 2){</p><pre><code>//不需要再用this.x = x进行赋值。</code></pre><p>  }<br>}</p><p>const point = new Point(24, 50);<br>//但是public方法下，依旧可以重新赋值，在实际工作中是非常危险的。<br>point.x = 30;<br>point.y =5;</p><pre class="line-numbers language-none"><code class="language-none">- 所以可以使用private，把公有变成私有，就能让外部无法访问。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  class Point implements IPoint{</p><pre><code>constructor(private x: number, private y: number = 2){}</code></pre><p>  }<br>//尝试使用point.x = 30进行修改则会报错。</p><pre class="line-numbers language-none"><code class="language-none">- 但是又会出现新的问题，private会导致和IPoint接口声明的成员不一致。**接口的成员变量都默认为public**。设置为private会导致Point类报错。  - 最直接的解决方式是**在IPoint接口中直接删除x,y这两个公有变量。**  - 考虑到有从外部访问成员变量的需要，要用**getter，setter**这两个方法。比如getDistances函数就需要访问x,y。    - getter,setter: 把class的私有属性封装一下，让外部通过特定的方法(getter,setter)进行访问。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  //setter作用就是在内部和外部建立一个缓冲带。<br>  setX = (value: number) =&gt;{</p><pre><code>if(value &lt; 0 ){  throw new Error("value 不能小于0");}this.x = value;</code></pre><p>  }<br>  point.setX(10);<br>  //point.setX(-9);//运行时会提示错误。</p><p>  //间接获取class Point中的横坐标<br>  getX = () =&gt;{</p><pre><code>return this.x;</code></pre><p>  }<br>  console.log(point.getX());</p><p>  //同理可以对纵坐标进行getter，setter的设置。<br>  setY = (value: number) =&gt;{…}<br>  getY = () =&gt;{}</p><p>  //同时需要在IPoint接口添加getter，setter。<br>  interface IPoint{</p><pre><code>drawPoint:()=&gt;void; //打印坐标点信息getDistances: (p:IPoint) =&gt; number; //需要传入对方坐标点信息getX: () =&gt; numbergetY: () =&gt; numbersetX: (value) =&gt; voidsetY: (value) =&gt; void</code></pre><p>  }</p><p>  //现在就可以用 getter, setter来让getDistances访问x,y的值了</p><pre><code>getDistances = (p: IPoint) =&gt;{    return Math.pow(p.getX() - this.x, 2) + Math.pow(p.getY()-this.y,2)  }}</code></pre><pre class="line-numbers language-none"><code class="language-none">- ts还提供了**getter,setter懒人包**:  - 时刻注意要**大写**  - 使用懒人包至少需要target为ES5或者更高版本。  - 设置编译器版本：`` tsc -t es5 [需要编译的文件名.ts]``<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre><code>//改写上述setX = () =&gt;{...}set X(value: number){...}get X(){...}//使用：如果需要赋值直接使用大写的Xpoint.X = 10;console.log(point.X)//但是使用懒人包也需要在IPoint接口中定义：//直接使用大写的X进行定义：interface IPoint{  drawPoint:()=&gt;void; //打印坐标点信息  getDistances: (p:IPoint) =&gt; number; //需要传入对方坐标点信息  X: number  Y: number</code></pre><p>  }</p>  <pre class="line-numbers language-none"><code class="language-none">#### Generic- **Generic泛型**- 考虑到**可重用性**，不仅支持当前的数据类型，也支持未来的数据类型而存在。- 使用一个identity函数做例子:  - 不用泛型的话:`` function identity(arg: number): number {    return arg;    } ``  - 使用Any的话:`` function identity(arg: any): any {    return arg;    } ``   - 但是使用Any我们只能知道有任意类型的数据被传入和返回。**并不能绑定和追踪两个值的类型。**  - 所以使用泛型: `` function identity&lt;T&gt;(arg: T): T {    return arg;    } ``- **泛型是可以帮助捕获用户传入的类型，同时使用这个类型当做返回值的类型。**- 同样是声明数字数组:   - 普通声明：`` let list1: number[] = [1,2,3,4]``  - 泛型声明：`` let list2: Array&lt;number&gt; = [1,2,3,4]``- 使用例子:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>//返回数组最后一位元素<br>let lastInArray = <t>(arr: T[]) =&gt;{<br>  return arr[arr.length - 1]<br>}<br>//会识别l1类型为number<br>const l1 = lastInArray([1,2,3,4]);<br>//会识别l2类型为string<br>const l2 = lastInArray([“a”,”b”,”c”]);<br>//因为有指定类型，所以l3的类型为string | number的数组<br>const l3 = lastInArray&lt;string | number&gt;([“a”,”b”,”c”]);</t></p><p>//也可以传入一个默认类型参数<br>let makeTuple = &lt;T, Y = number&gt;(x: T, y: Y) = &gt; [x,y]</p><p>//帮我们动态匹配类型，v1识别为 string | number 的元祖类型<br>const v1 = makeTuple(1, “one”)<br>//v2显式定义了类型，因为默认参数是number，就可以省略第二个参数<br>const v2 = makeTuple<boolean>(true,1);<br>```</boolean></p></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode+腾讯云+PicGo图床</title>
      <link href="/2022/04/05/teng-xun-yun-typora-pei-zhi/"/>
      <url>/2022/04/05/teng-xun-yun-typora-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="vscode-腾讯云-PicGo图床"><a href="#vscode-腾讯云-PicGo图床" class="headerlink" title="vscode+腾讯云+PicGo图床"></a>vscode+腾讯云+PicGo图床</h1><p><strong>1. 配置腾讯云COS存储桶</strong></p><ul><li>做图床的话，访问权限要选”公有读私有写“。<br><img src="https://choichoi-1310042158.cos.ap-singapore.myqcloud.com/20220405011149.png"></li></ul><p><strong>2. 配置密钥</strong></p><ul><li>使用PicGo做插件的话要配置一个密钥让插件使用。</li><li>密钥配置网址：<a href="https://console.cloud.tencent.com/cam/capi">https://console.cloud.tencent.com/cam/capi</a>  </li><li>配置好的密钥：<br><img src="https://choichoi-1310042158.cos.ap-singapore.myqcloud.com/20220405013142.png"></li></ul><p><strong>3. PicGo插件</strong></p><ul><li>在vscode安装PicGo插件。<br><img src="https://choichoi-1310042158.cos.ap-singapore.myqcloud.com/20220405011640.png"></li></ul><p><strong>4. 配置PicGo</strong></p><ul><li>找到PicGo的设置， 主要配置如下：</li><li>Picgo › Pic Bed: Current，选择”tcyun”，即腾讯云。<br><img src="https://choichoi-1310042158.cos.ap-singapore.myqcloud.com/20220405012031.png"></li><li>Picgo › Pic Bed › Tcyun: App ID，设置为腾讯云的APPID，是第二步的一串数字。</li><li>Picgo › Pic Bed › Tcyun: Area，腾讯云的存储桶所在区域，在创建存储桶时提供，如“ap-singapore”。</li><li>Picgo › Pic Bed › Tcyun: Bucket，存储桶的名称，一般是桶名 + “-” + 一串数字，如“test-1310232109“。</li><li>Picgo › Pic Bed › Tcyun: Custom Url，访问域名，直接填请求域名，如”<a href="https://test-1310232109.cos.ap-singapore.myqcloud.com&quot;/">https://test-1310232109.cos.ap-singapore.myqcloud.com"</a></li><li>Picgo › Pic Bed › Tcyun: Secret ID，在上面第二步生成。</li><li>Picgo › Pic Bed › Tcyun: Secret Key，在上面第二步生成。</li><li>Picgo › Pic Bed › Tcyun: Version，使用默认的 v5 就可以。  </li></ul><p><strong>5. 上传方法</strong></p><ul><li>Mac可以把要上传的图片先复制在剪贴板，然后在要插入的地方使用快捷键Command + Option + U。</li><li>Windows可以用Ctrl + Alt + U。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于垃圾回收，内存管理，内存泄漏。</title>
      <link href="/2022/04/04/guan-yu-nei-cun-xie-lou/"/>
      <url>/2022/04/04/guan-yu-nei-cun-xie-lou/</url>
      
        <content type="html"><![CDATA[<p>（还没写完，先留着。刚配置完图床。）</p><h1 id="关于垃圾回收、内存管理、内存泄漏。"><a href="#关于垃圾回收、内存管理、内存泄漏。" class="headerlink" title="关于垃圾回收、内存管理、内存泄漏。"></a>关于垃圾回收、内存管理、内存泄漏。</h1><ul><li>这篇文章主要还是因为面试被问到了内存泄漏。在红宝书上看到过但没有仔细研究，导致一问三不知。接下来重温红宝书。</li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h2 id="垃圾回收（GC）"><a href="#垃圾回收（GC）" class="headerlink" title="垃圾回收（GC）"></a>垃圾回收（GC）</h2><ul><li>垃圾回收（GC）即Garbage Collection。</li></ul><h2 id="内存泄漏是什么？"><a href="#内存泄漏是什么？" class="headerlink" title="内存泄漏是什么？"></a>内存泄漏是什么？</h2><ul><li>个人的理解是，电脑分配给浏览器(或者任何runtime)的内存不够用来跑自己写的<del>垃圾</del>代码了。<del>JS运行占的内存满得都溢出来了。</del><ul><li>比如函数被调用很多次，或者写一个千万级别的循环就会导致浏览器非常卡，甚至造成崩溃。</li><li>特别是内存不够多的设备上，内存没办法分配给浏览器很多，这时候也会有内存泄漏的问题。</li></ul></li></ul><h2 id="为什么会导致？"><a href="#为什么会导致？" class="headerlink" title="为什么会导致？"></a>为什么会导致？</h2><h3 id="意外声明全局变量"><a href="#意外声明全局变量" class="headerlink" title="意外声明全局变量"></a>意外声明全局变量</h3><ul><li>是最常见也</li></ul><ul><li> 参考：<a href="https://juejin.cn/post/6981588276356317214">https://juejin.cn/post/6981588276356317214</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/12/06/hello-world/"/>
      <url>/2021/12/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
